<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh" xml:lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>flink</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header>
    <nav>
        <a href="/it-basics">Home</a>
        <a href="https://github.com/shao-wang-me">Me</a>
    </nav>
</header>
<h1 id="apache-flink">Apache Flink</h1>
<p>Hi  how are you?</p>
<p>Hi \ how are you?</p>
<p>Reference: <a href="https://flink.apache.org/" class="uri">https://flink.apache.org/</a></p>
<h2 id="concepts">Concepts</h2>
<ol type="1">
<li><p>What is Apache Flink?</p>
<p>Apache Flink is a stream processing framework that can be:</p>
<ol type="1">
<li>distributed</li>
<li>stateful</li>
</ol></li>
<li><p>What are the use cases of Flink?</p></li>
<li><p>What are the optimisations Flink has for bounded data streams?</p></li>
<li><p>What layers of APIs does Flink have?</p>
<p>Reference: <a href="https://ci.apache.org/projects/flink/flink-docs-stable/concepts/index.html#flinks-apis" class="uri">https://ci.apache.org/projects/flink/flink-docs-stable/concepts/index.html#flinks-apis</a></p>
<figure>
<img src="flink-api-layers.svg" alt="Flink API layers" /><figcaption>Flink API layers</figcaption>
</figure>
<p>Flink has four layers of API (from low to high):</p>
<ol type="1">
<li>Stateful Stream Processing. It is embedded into the <code>DataStream</code> API via <code>ProcessFunction</code>s. It offers stateful and timely stream processing.</li>
<li><code>DataStream</code>/<code>DataSet</code> API. <code>DataStream</code> API works on both bounded and unbounded streams and <code>DataSet</code> API works on only bounded streams.</li>
<li>Table API. A declarative DSL centered around tables. A table has a schema.</li>
<li>SQL. Similar to the Table API but supports SQL syntax.</li>
</ol>
<p>Each layer of API works on top of and interacts with the lower level API.</p></li>
<li><p>What is exactly-once state consistency?</p></li>
<li><p>What is an operator in Flink?</p>
<p>Reference: <a href="https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/operators/index.html" class="uri">https://ci.apache.org/projects/flink/flink-docs-stable/dev/stream/operators/index.html</a></p>
<p>Operators transform one or more DataStreams into a new DataStream. For example, <code>map</code>, <code>filter</code>, <code>keyBy</code>, <code>process</code> and <code>reduce</code>.</p>
<p>Inside an operator, you need to give a user-defined function. For example:</p>
<pre><code>data.map(new MapFunction&lt;String, Integer&gt; () {
    public Integer map(String value) { return Integer.parseInt(value); }
});</code></pre>
<p>or with Java 8 Lambdas: <code>data.filter(s -&gt; s.startsWith("http://"));</code>.</p></li>
<li><p>What is a Flink logical graph/dataflow graph/job graph?</p>
<p>The three names are referring to the same thing. It is a directed graph of operators. The edges indicate the data flow between nodes (operators).</p></li>
<li><p>What is a physical graph/execution graph?</p>
<p>A physical graph is derived from a logical graph for execution in a distributed runtime. Instead of operators, the nodes are Flink tasks. You can think of a logical graph as a conceptual definition, and the physical graph is a concrete execution plan with things like parallelism and resource allocation considered.</p></li>
<li><p>What is a Flink job?</p>
<p>A Flink job is a runtime representation of a logical graph.</p></li>
<li><p>What is a Flink application?</p>
<p>A Java application that submits jobs. Submitting jobs is usually done by calling <code>execute()</code> on an execution environment.</p></li>
<li><p>How does Flink handle states?</p>
<p>“Flink’s operations can be stateful”. State is always stored locally in an instance, rather than globally across the cluster. “Each parallel instance is responsible for handling events for a specific group of keys, and the state for those keys is kept locally”.</p>
<p>State is kept on the JVM heap or in on-disk data structures (this is not persistence) when it is too large.</p></li>
<li><p>What is stateful functions?</p></li>
<li><p>How does Flink handle failures?</p>
<p>Flink captures asynchronous snapshots of the entire state of the distributed pipeline.</p></li>
<li><p>What notions of time (e.g. event time and processing time) does Flink support?</p>
<p>Flink supports three notions of time: event time, ingestion time and processing time.</p></li>
<li><p>What is a watermark in Flink?</p>
<p>If an event <strong>e</strong> arrives at time <strong>t</strong> and denote the watermark for time <strong>t</strong> as <strong>t<sub>w</sub></strong> (<strong>t<sub>w</sub></strong> ≥ <strong>t</strong>). Any event with an event time (the actual the event happens) earlier than <strong>t</strong> but arrives later than <strong>t<sub>w</sub></strong> is a late event. Flink waits until <strong>t<sub>w</sub></strong> to ensure ordered processing.</p></li>
<li><p>How does Flink handle late data?</p></li>
</ol>
<h2 id="architecture-and-deployment">Architecture and deployment</h2>
<pre class="puml"><code>@startuml
digraph flink {
    label = &quot;Apache Flink Architecture&quot;
    compound = true
    node [shape = box, style = rounded]

    subgraph cluster {
        label = &quot;Flink cluster, a runtime&quot;

        subgraph cluster_job_manager {
            label = &quot;JobManager+, an orchestrator\nThere can be multiple \&quot;standby\&quot; JobManagers, with the main one the \&quot;leader\&quot;.&quot;

            job_master [label = &quot;JobMaster*&quot;]
            resource_manager [label = &quot;ResourceManager\nmanages task slots&quot;]
            dispatcher [label = &quot;Dispatcher\nexposes a REST API and runs Flink WebUI&quot;]

            dispatcher -&gt; job_master [label = &quot;starts new&quot;]
        }
        
        subgraph cluster_task_manager {
            label = &quot;TaskManager+, i.e. worker&quot;

            task_slot [label = &quot;Task Slot+\nseparates memory&quot;]
        }

        job [label = &quot;Job*&quot;]
        task [label = &quot;Task*&quot;]

        task_slot -&gt; resource_manager [label = &quot;registers to&quot;, lhead = cluster_job_manager]

        job_master -&gt; job [label = &quot;manages one&quot;]
        job -&gt; task
    }

    app [label = &quot;Application (a Java app submits Jobs)&quot;]
}
@enduml</code></pre>
<figure>
<img src="flink-deployment.svg" alt="Flink deployment" /><figcaption>Flink deployment</figcaption>
</figure>
<ol type="1">
<li><p>What is a standalone Flink cluster?</p>
<p>A standalone Flink cluster <strong>without a resource provider</strong> (e.g. Kubernetes, YARN and Mesos). Flink manages the cluster itself directly in this mode.</p></li>
<li><p>What is a resource provider?</p>
<p>Flink can be deployed through different resource provider frameworks, such as Kubernetes, YARN or Mesos.</p></li>
<li><p>What is a high availability service provider?</p>
<p>With a high availability service provider (e.g. Zookeeper, Kubernetes HA), Flink can recover from JobManager faults. It can have multiple standby JobManagers to failover faster.</p></li>
<li><p>What are deployment modes?</p>
<figure>
<img src="flink-deployment-modes.svg" alt="Flink deployment modes" /><figcaption>Flink deployment modes</figcaption>
</figure>
<p>Depending on which component submits jobs, how many jobs a JobManager handles and how long a JobManager lives, there are three deployment modes.</p>
<p>Note that the concept of these nodes are different from whether it is a standalone cluster or not although the per-job mode is not supported by a standalone cluster.</p>
<ol type="1">
<li><p>Application mode</p>
<p>In this mode, there is no client, so the Flink Application (whichever component creates and submits jobs) is on the cluster itself. The whole cluster is created for this application and torn down when the application finishes.</p></li>
<li><p>Per-job mode</p>
<p>In this mode, there is a client Flink Application. A new cluster is created for each job and torn down when the job is finished.</p></li>
<li><p>Session mode</p>
<p>In this mode, the Flink cluster is not bound to an application or job. The cluster’s resources are used by all Flink applications and jobs.</p></li>
</ol>
<p>These modes have different implications of cluster lifecycle (thus affecting the cluster initialisation and termination time), resource isolation (thus affecting the performance and failover).</p></li>
</ol>
<h2 id="datastream-api">DataStream API</h2>
<ol type="1">
<li><p>What can be streamed?</p>
<p>In <code>DataStream&lt;T&gt;</code>, <code>T</code> can be anything Java can serialise.</p>
<p>Flink has its own serializer which is used for basic types (<code>String</code>, <code>Boolean</code>, <code>Integer</code>, <code>Long</code> and <code>Array</code>) and composite types (Flink’s own <code>Tuple0</code> - <code>Tuple25</code> and <a href="file:///C:/Users/ws/Downloads/apache_flink_doc/ci.apache.org/projects/flink/flink-docs-release-1.12/learn-flink/datastream_api.html#pojos">POJOs</a>).</p>
<p>For other types, Flink falls back to use Kryo. You can use other serializers such as Avro.</p></li>
<li><p>Why does it need to be serializable to be streamable?</p>
<p>Because Flink needs to distribute the stream data and also snapshot the entire state of the distributed pipeline for failure recovery.</p></li>
</ol>
<h2 id="operations">Operations</h2>
<ol type="1">
<li><p>What Java versions does Flink requires?</p>
<p>Java 8 or 11. If you like This and</p></li>
<li><p>How to start a Flink cluster and run a Flink application (to create and submit jobs)?</p>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Resource provider ↓ Deployment mode →</th>
<th>Application</th>
<th>Per-job</th>
<th>Session</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Standalone cluster</td>
<td>Put Flink Application jar in classpath, one way: <code>cp ./examples/streaming/TopSpeedWindowing.jar lib/</code>; launch JobManager: <code>./bin/standalone-job.sh start --job-classname org.apache.flink.streaming.examples.windowing.TopSpeedWindowing</code>; start TaskManager: <code>./bin/taskmanager.sh start</code>; stop: <code>./bin/taskmanager.sh stop</code>, <code>./bin/standalone-job.sh stop</code>.</td>
<td>Not supported</td>
<td>Start cluster: <code>./bin/start-cluster.sh</code>; submit job: <code>./bin/flink run ./examples/streaming/TopSpeedWindowing.jar</code>, this starts a short-lived client Flink application.</td>
</tr>
<tr class="even">
<td>Standalone in Docker</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>Standalone in Kubernetes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Kubernetes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>YARN</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Mesos</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table></li>
<li><p>Does Flink have a Web UI?</p>
<p>Yes. By default, the WebUI of a Flink cluster is exposed at <a href="http://localhost:8081/" class="uri">http://localhost:8081/</a>.</p></li>
<li><p>Does Flink have a REST API?</p>
<p>Yes. By default, the API is exposed at <a href="http://localhost:8081/" class="uri">http://localhost:8081/</a> as well. For example, <a href="http://localhost:8081/jobs" class="uri">http://localhost:8081/jobs</a> list all the jobs.</p></li>
</ol>
</body>
</html>
